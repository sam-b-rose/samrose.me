---
title: Minimal XState with Hooks
slug: minimal-xstate-with-hooks
isPublished: true
publishedOn: 2020-11-30T01:26:58+0000
abstract: Replacing the reducer with declarative state management
category: react
interactive: false
---

import visualizerToggleMachineSrc from './images/visualizer-toggle-machine.png';
import Image from '@components/Image';

Reducers are a common pattern for tracking state in a React component. Que simple toggle button example showcasing sed reducer pattern:

```jsx
import React, { useReducer } from 'react';

const reducer = (state, action) => {
  switch (action.type) {
    case 'TOGGLE':
      return state === 'active' ? 'inactive' : 'active';
    default:
      return state;
  }
};

const Toggler = () => {
  const [state, dispatch] = useReducer('inactive');

  return (
    <button onClick={() => dispatch('TOGGLE')}>
      {state === 'inactive' ? 'Activate' : 'Deactivate'}
    </button>
  );
};
```

This is a simple reducer. However, if you aren't familar with the reducer pattern, this may look very intemedating and unclear how the state is updated. Using a state machine is an alternative way to convert this swtich statement into a more declarative configuration describing the component state transitions.

## Starting small and simple

The React package from XState uses the full XState library. If your application state needs are simple, the `@xstate/fsm` might be a sufficient start. This package is XState's minimal solution for creating finite state machines – a 1kb implementation of XState.

Instead of including all of XState and the React package, lets wrap `@xstate/fsm` with our own `useMachine` hook.

```js
import { useState, useMemo, useEffect } from ‘react’;
import { interpret } from ‘@xstate/fsm’;

export function useMachine(machine) {
  // Keep track of the current machine state
  const [current, setCurrent] = useState(machine.initialState);
  // Start the service (only once!)
  const service = useMemo(
    () =>
      interpret(machine)
        .onTransition(state => {
          // Update the current machine state when a transition occurs
          if (state.changed) {
            setCurrent(state);
          }
        })
        .start(),
    []
  );
  // Stop the service when the component unmounts
  useEffect(() => {
    return () => service.stop();
  }, []);
  return [current, service.send];
}
```

## Replacing with our minimal machine hook

Now that we have our custom `useMachine` hook, let's put it into use!

```
import React from 'react';
import { createMachine } from '@xstate/fsm';
import { useMachine } from '../hooks/useMachine';

const toggleMachine = createMachine({
  id: 'toggle',
  initial: 'inactive',
  states: {
    inactive: { on: { TOGGLE: 'active' } },
    active: { on: { TOGGLE: 'inactive' } }
  }
});

const Toggler = () => {
  const [state, send] = useMachine(toggleMachine);

  return (
    <button onClick={() => send('TOGGLE')}>
      {state === 'inactive' ? 'Activate' : 'Deactivate'}
    </button>
  );
};
```

## Visualizing our state machine

XState also has a visualized that allows you to load and preview your state machine configuration. The visualizer can create a [sharable link](https://xstate.js.org/viz/?gist=8920aced5b898be4f270e82171434d96) of our toggle machine.

<Image src={visualizerToggleMachineSrc} alt="Our toggle machine visulaized" />

Instead of using a framework specific API such as `useReducer`, our state logic is completely portable and can be used independent of React in any framework.

## Upgrade ready

Say we have decided it makes sense for our project to use the full XState library. We can simply replace `@xstate/fsm` with `xstate`. Similarly, we can use the fully supported `@xstate/react` package instead of our custom `useMachine` hook.

```
import React from 'react';
import { Machine } from 'xstate';
import { useMachine } from '@xstate/react';

const toggleMachine = Machine({
  id: 'toggle',
  initial: 'inactive',
  states: {
    inactive: { on: { TOGGLE: 'active' } },
    active: { on: { TOGGLE: 'inactive' } }
  }
});

const Toggler = () => {
  const [state, send] = useMachine(toggleMachine);

  return (
    <button onClick={() => send('TOGGLE')}>
      {state === 'inactive' ? 'Activate' : 'Deactivate'}
    </button>
  );
};
```

Thats it! Now we have all the more advanced capabilities of XState without having to make a single change to our state logic.
